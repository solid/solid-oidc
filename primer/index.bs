<pre class='metadata'>
Title: Solid OIDC Primer
Boilerplate: issues-index no
Boilerplate: style-darkmode off
Boilerplate: omit conformance
Local Boilerplate: logo yes
Shortname: solid-oidc-primer
Level: 1
Status: w3c/ED
Group: Solid Community Group
Favicon: https://solidproject.org/TR/solid.svg
ED: https://solid.github.io/solid-oidc/primer/
TR: https://solidproject.org/TR/oidc-primer
!Editor's Draft: [https://solid.github.io/solid-oidc/primer/](https://solid.github.io/solid-oidc/primer/)
!License: [MIT License](http://purl.org/NET/rdflicense/MIT1.0)
Repository: https://github.com/solid/solid-oidc
Markup Shorthands: markdown yes
Max ToC Depth: 2
Editor: [Jackson Morgan](https://github.com/jaxoncreed)
Editor: [Aaron Coburn](https://github.com/acoburn)
Editor: [Matthieu Bosquet](https://github.com/matthieubosquet)
Metadata Order: This version, Latest published version, Editor's Draft, Test Suite, *, !*
Metadata Include: Editor's Draft off
Abstract:
  The Solid OpenID Connect (Solid OIDC) specification defines how resource servers
  verify the identity of relying parties and end users based on the authentication
  performed by an OpenID provider. Solid OIDC builds on top of OpenID Connect 1.0.
  This primer is designed to provide the reader with the basic knowledge required
  to understand Solid OpenID Connect authentication flows. It introduces the basic
  concepts of authentication in the Solid ecosystem.
</pre>

# Introduction # {#intro}

This document outlines in details how Alice (end-user) asserts her identity
(logs in) when using Decent Photos (relying party) to access data in hers and
Bob's Solid Storage (resource servers).

# Definitions # {#definitions}

<dl>
  <dt id="openid-provider">OpenID Provider (OP)</dt>
  <dd>An OAuth 2.0 authorization server implementing OpenID Connect as [defined in the OpenID Connect Core 1.0 specification](https://openid.net/specs/openid-connect-core-1_0.html). [[OIDC.Core]]</dd>
  <dt id="relying-party">Relying Party (RP)</dt>
  <dd>A client application using OpenID Connect to make resource requests on behalf of the resource owner. Client is one of the four roles [defined in the OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-1.1). [[RFC6749]]</dd>
  <dt id="resource">Resource</dt>
  <dd>Something denoted by an IRI or a literal as [defined in RDF 1.1](https://www.w3.org/TR/rdf11-concepts/#resources-and-statements). [[rdf11-concepts]]</dd>
  <dt id="resource-owner">Resource Owner</dt>
  <dd>An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. Resource Owner is one of the four roles [defined in the OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-1.1). [[RFC6749]]</dd>
  <dt id="resource-server">Resource Server (RS)</dt>
  <dd>A server hosting resources, capable of accepting and responding to protected resource requests using access tokens. RS is one of the four roles [defined in the OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-1.1). [[RFC6749]]</dd>
  <dt id="solid-data-pod">Solid Storage</dt>
  <dd>A Solid compliant Resource Server as [defined in the Solid Protocol](https://solidproject.org/TR/protocol#data-pod). [[Solid.Protocol]]</dd>
  <dt id="solid-oidc">Solid OpenID Connect (Solid OIDC)</dt>
  <dd>The specification defining authentication in the Solid ecosystem. [[Solid.OIDC]]</dd>
  <dt id="webid">WebID</dt>
  <dd>A WebID is an HTTP URI which refers to an Agent (Person, Organization, Group, Device, etc.) as [defined in the WebID 1.0 specification](https://dvcs.w3.org/hg/WebID/raw-file/tip/spec/identity-respec.html#introduction). [[WebID]]</dd>
</dl>

# Actors # {#actors}

Several actors are at play in our example Solid OIDC authentication flows:

<dl>
  <dt id="alice">Alice</dt>
  <dd>Alice will be providing consent for Decent Photos to make resource requests
 on her behalf. Let's assume that Alice is using a standard web browser.</dd>
  <dt id="alice-op">Alice's OP</dt>
  <dd>Alice's OpenID Provider, also known as an Identity Provider (IdP), is the
 service responsible for authorizing our third-party web app (Decent Photos) by
 providing it with the tokens necessary to gain access to any resource Alice has
 access to (in any Storage, for example Alice's and Bob's). In our example, Alice's
 OP is hosted at `https://secureauth.example`.</dd>
  <dt id="alice-webid">Alice's WebID</dt>
  <dd>Alice's WebID is `https://alice.coolpod.example/profile/card#me`. The WebID
 profile document denoted by URI `https://alice.coolpod.example/profile/card` is
 hosted on Alice's Solid Storage and contains the URI of her OP. Alice's WebID
 `https://alice.coolpod.example/profile/card#me` serves as her unique identifier
 in the Solid Ecosystem.</dd>
  <dt id="rp">RP</dt>
  <dd>The Decent Photos application is a third party photo viewing web application.
 It is OIDC compliant and will therefore be referred to as the Relying Party. The
 Decent Photos web app allows its users to view photos they have access to. For
 example, Alice's and her friend Bob's photos. In our example, Decent Photos is
 hosted at `https://decentphotos.example`.</dd>
  <dt id="decentphotos-rp-webid">RP's Client ID Document</dt>
  <dd>Decent Photos is a Solid compliant application and has a URI of its own,
 which resolves to a Client ID Document. An RP's Client ID Document
 contains information identifying them as a registered OAuth 2.0 client
 application. Decent Photo's URI is `https://decentphotos.example/webid#this`</dd>
  <dt id="bob-pod">Bob's Storage</dt>
  <dd>We will be trying to access photos stored in Bob's Storage. In our example, Bob
 is a friend of Alice and has previously indicated via access control that Alice
 may access some of his photos using any web app. Bob's Solid Storage is hosted at
 `https://bob.otherpod.example`.</dd>
  <dt id="bob-auth-server">Authorization Server for Bob's Storage</dt>
  <dd>The Authorization Server (AS) connected to Bob's Storage will issue access tokens that
 can be used with Bob's Storage. In these examples, this is hosted at
 `https://auth.otherpod.example`.</dd>
</dl>

# Solid OIDC Flow # {#solid-oidc-flow}

## Authorization Code Grant with PKCE Authorization Flow ## {#authorization-code-pkce-flow}

The Authorization Code grant with PKCE is the primary OAuth 2.0 authorization flow
recommended by the Solid OIDC. It is defined by the PKCE RFC [[RFC7636]] and
described here in the Solid OIDC context.

<img src="primer-login.mmd.svg" width="980" />

<h4 id="authorization-code-pkce-flow-step-1" class="no-num">1. Alice uses the Decent Photos web app</h4>

Alice has heard of a great new site that allows her to view her friend's photos and tag faces.
She navigates to `https://decentphotos.example` via her web browser which returns an HTML page.
This page contains JavaScript that will help with the authentication process.

<h4 id="authorization-code-pkce-flow-step-2" class="no-num">2. Alice selects her OP or WebID</h4>

Before decentphotos can start displaying images, Alice needs to start the
process of providing consent. To do so, she must either provide her WebID
(`https://alice.coolpod.example/profile/card#me`) or the URL of her OP
(`https://secureauth.example`).

Although it is not the case for Alice, a user's Storage and OP can be hosted under the
same domain. For example, Bob could have a Storage at `https://bob.solidpod.example.com`,
an OP at `https://solidpod.example.com/`, and a WebID of
`https://bob.solidpod.example.com/profile/card#me`.

<h4 id="authorization-code-pkce-flow-step-2.1" class="no-num">2.1 Retrieve Profile (only needed if a WebID is provided)</h4>

If Alice enters her WebID's URL rather than her OP's URL, a request should be
made to determine her OP. To do so, a request should be made to Alice's WebId:

```http
GET https://alice.coolpod.example/profile/card#me
```

It will return a body similar to this:

```ttl
@prefix : <#>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix schema: <http://schema.org/>.

<>
    a foaf:PersonalProfileDocument ;
    foaf:maker <https://localhost:8443/profile/card#me> ;
    foaf:primaryTopic <https://localhost:8443/profile/card#me> .

:me a foaf:Person ;
    a schema:Person ;
    foaf:name "Alice" ;
    solid:oidcIssuer <https://secureauth.example> ;
```

The OP URL is located at `:me -> solid:oidcIssuer`

<h4 id="authorization-code-pkce-flow-step-3" class="no-num">3. Retrieves OP Configuration</h4>

Now that we have Alice's OP's URL, the RP must make a request to retrieve the
OP's configuration. This is always located at the OP's issuer URL followed by
`/.well-known/openid-configuration`.

```http
GET https://secureauth.example/.well-known/openid-configuration
```

The [openid-configuration](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata)
describes everything the client will need to know to authorize with Alice's specific OP.

Response Body:
```json
{
    "issuer": "https://secureauth.example",
    "authorization_endpoint": "https://secureauth.example/authorize",
    "token_endpoint": "https://secureauth.example/token",
    "userinfo_endpoint": "https://secureauth.example/userinfo",
    "registration_endpoint": "https://secureauth.example/register",
    "end_session_endpoint": "https://secureauth.example/endsession",
    "jwks_uri": "https://secureauth.example/jwks",
    "response_types_supported": [
        "code"
    ],
    "grant_types_supported": [
        "authorization_code",
        "refresh_token"
    ],
    "subject_types_supported": [
        "public"
    ],
    "claims_supported": [
        "sub",
        "webid"
    ],
    "scopes_supported": [
        "openid",
        "webid",
        "profile",
        "email",
        "offline_access"
    ],
    "token_endpoint_auth_methods_supported": [
        "client_secret_basic"
    ],
    "token_endpoint_auth_signing_alg_values_supported": [
        "ES256"
    ],
    "request_object_signing_alg_values_supported": [
        "ES256"
    ],
    "id_token_signing_alg_values_supported": [
        "ES256"
    ],
    "code_challenge_methods_supported": [
        "plain",
        "S256"
    ],
    "claims_parameter_supported": false,
    "request_parameter_supported": true,
    "request_uri_parameter_supported": false,
    "require_request_uri_registration": false
}
```

The thing we care about here is the `authorization_endpoint` field. This will
be the url we use when we're ready to send an authorization request to the OP.

Note that we only support the `code` response type. The OIDC discovery
specification states that Dynamic OpenID Providers MUST also support
`id_token` and `token id_token`. However, [implicit flows should not be used for
security reasons](https://oauth.net/2/grant-types/implicit/). Therefore, we
don't recommend enabling them. For the same reason, we do not support the
`implicit` grant type.

<h4 id="authorization-code-pkce-flow-step-4" class="no-num">4. Generates PKCE code challenge and code verifier</h4>

To follow the [PKCE code flow](https://oauth.net/2/pkce/) we need to generate a
code challenge and code verifier as instructed in the [Proof Key for Code
Exchange spec](https://tools.ietf.org/html/rfc7636#section-4.1).

We start by generating a code verifier. The can be done by creating a
cryptographically random string. Let's say ours looks like this: `"JXPOuToEB7"`.

Now using the code verifier, we construct a code challenge. This can be made by transforming
the code verifier with Sha 256: `BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))`. Here's our
code challenge: `"HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0"`

<h4 id="authorization-code-pkce-flow-step-5" class="no-num">5. Saved code verifier to session storage</h4>

Now, we save the code verifier (`"JXPOuToEB7"`) to session storage. We'll need it later to
confirm to the OP that this is the app that initiated the request. Do not save the code
challenge anywhere.

<h4 id="authorization-code-pkce-flow-step-6" class="no-num">6. Authorization request</h4>

Now that the web app is registered, we can finally make an auth request to authorize the web
application.

```http
GET https://secureauth.example/authorize?response_type=code&
redirect_uri=https%3A%2F%2Fdecentphotos.example%2Fcallback&
scope=openid%20webid%20offline_access&
client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this&
code_challenge_method=S256&
code_challenge=HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0
```

That URL might look a little complex, but it's essentially a request to
`https://secureauth.example/authorize` with the following URL parameters:

- `response_type=code` indicates the desired response data.
- `redirect_uri=https%3A%2F%2Fdecentphotos.example%2Fcallback`:
    The url that the OP will redirect to once the user has logged in (`https://decentphotos.example/callback`).
- `scope=openid%20webid%20offline_access`: a list of [OIDC scopes](https://auth0.com/docs/scopes/current/oidc-scopes)
    (attributes of the RS to which this token should have access) separated by spaces (%20).
    - `openid` is a scope that is needed to verify Alice's identity.
    - `webid` is required by the Solid OIDC specification to denote a WebID login.
    - `offline_access`: Is required to get a refresh token.
- `client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this`: Usually the client id of a Solid
    application is the app's URI (in our case `https://decentphotos.example/webid#this`) as seen here.
- `code_challenge_method=S256`: Tells the OP that our code challenge was transformed using SHA-256.
- `code_challenge=HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0`: The code challenge we generated before.

Note: If the app doesn't have a URI, you can either register an app using static registration
via some UI on the OP or use [dynamic registration](https://openid.net/specs/openid-connect-registration-1_0.html).

<h4 id="authorization-code-pkce-flow-step-7" class="no-num">7. Fetch RP Client ID Document</h4>

If an app URI is provided as the client id (see note above to see other options), we must
fetch that app URI to confirm its validity.

For the URI `https://decentphotos.example/webid#this`, request the Client ID Document with:
```http
GET https://decentphotos.example/webid
```

Response:
```jsonld
{
  "@context": [ "https://www.w3.org/ns/solid/oidc-context.jsonld" ],

  "client_id": "https://decentphtos.example/webid#this",
  "client_name": "DecentPhotos",
  "redirect_uris": [ "https://decentphotos.example/callback" ],
  "post_logout_redirect_uris": [ "https://decentphotos.example/logout" ],
  "client_uri": "https://decentphotos.example/",
  "logo_uri": "https://decentphotos.example/logo.png",
  "tos_uri": "https://decentphotos.example/tos.html",
  "scope": "openid webid offline_access",
  "grant_types": [ "refresh_token", "authorization_code" ],
  "response_types": [ "code" ],
  "default_max_age": 3600,
  "require_auth_time": true
}
```

Notice that the application Client ID Document contains a JSON-LD representation of an
[OIDC Client Registration](https://tools.ietf.org/html/rfc7591#section-2).
It also must use the specific <code>"@context": ["https://www.w3.org/ns/solid/oidc-context.jsonld"]</code>.

<h4 id="authorization-code-pkce-flow-step-8" class="no-num">8. Validate redirect url with Client ID Document</h4>

Check to be sure that the `redirect_uri` value provided in the auth request
(`https://decentphotos.example/callback`) is listed in the `redirect_uris` array in the
Client ID Document. If it is not, the OP must reject the request. In our case, the
`redirect_uri` is valid, so we may continue.

<h4 id="authorization-code-pkce-flow-step-9" class="no-num">9. Alice Logs In</h4>

The OP should redirect to its login screen. The actual implementation of this is completely up
to the OP. A user can log in with her password, a TLS certificate, or any other proven method
of authentication. The important thing is that, thanks to the redirect, the control is now out
of the hands of the RP and is in complete control of the OP.

<h4 id="authorization-code-pkce-flow-step-10" class="no-num">10. Generate a code</h4>

Generate a cryptographically random string that will be used as a code (Let's say ours is
`m-OrTPHdRsm8W_e9P0J2Bt`). Store that string in a persistant keystore as the key for the client
id, the code challenge, the user's webid, their desired response types, and their scopes:

```json
{
  "m-OrTPHdRsm8W_e9P0J2Bt": {
    "client_id": "https://decentphotos.example/webid#this",
    "code_challenge": "HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0",
    "webid": "https://alice.coolpod.example/profile/card#me",
    "response_types": [ "code" ],
    "scope": [ "openid", "webid", "offline_access" ]
  }
}
```

<h4 id="authorization-code-pkce-flow-step-11" class="no-num">11. Send code to redirect url</h4>

Once Alice successfully logs in, the OP redirects back to the application via the provided
redirect uri, including useful information with it:

```http
302 redirect to: https://decentphotos.example/callback?code=m-OrTPHdRsm8W_e9P0J2Bt
```

This redirect gives decentphotos the code that it will exchange for an access token.

<h4 id="authorization-code-pkce-flow-step-12" class="no-num">12. Generates a DPoP Client Key Pair</h4>

Solid-OIDC depends on
[Demonstration of Proof-of-Possession (DPoP) tokens](https://tools.ietf.org/html/draft-ietf-oauth-dpop).
DPoP tokens ensure that third-party web applications can send requests to any number of
Storage servers while ensuring that malicious actors can't steal and replay a user's token.

The first step to generating a DPoP token is generating a public and private key pair on the
third-party RP. In our example, the private key is generated using elliptic curves and looks
like:

```json
{
    "kty": "EC",
    "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
    "use": "sig",
    "alg": "EC",
    "crv": "P-256",
    "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
    "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s",
    "d": "RrM4Ou_7PzjP24B4k06B9ZML16HbfzNPKFN11Z8c9_s"
}
```

From now on we will refer to this as `RP_PRIVATE_KEY`.

The public key looks like:
```json
{
    "kty": "EC",
    "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
    "use": "sig",
    "alg": "EC",
    "crv": "P-256",
    "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
    "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s"
}
```

<h4 id="authorization-code-pkce-flow-step-13" class="no-num">13. Generates a DPoP Header</h4>

Now that we generated a private key for the client, we need to generate the DPoP header. To do
so, we create a [JSON Web Token](https://jwt.io/introduction/) and sign it using the key we
generated.

Our token could look like the following (you can decode the token using https://jwt.io):
```text
eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiZkJ1STExTkdGbTQ4Vlp6RzNGMjVDOVJmMXYtaGdEakVnV2pEQ1BrdV9pVSIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiOWxlT2gxeF9IWkhzVkNScDcyQzVpR01jek1nUnpDUFBjNjBoWldfSFlLMCIsInkiOiJqOVVYcnRjUzRLVzBIYmVteW1vRWlMXzZ1cko0TFFHZXJQZXVNaFNEaV80In19.eyJodHUiOiJodHRwczovL3NlY3VyZWF1dGguZXhhbXBsZS90b2tlbiIsImh0bSI6InBvc3QiLCJqdGkiOiI0YmEzZTllZi1lOThkLTQ2NDQtOTg3OC03MTYwZmE3ZDNlYjgiLCJpYXQiOjE2MDMzMDYxMjgsImV4cCI6MTYwMzMwOTcyOH0.2lbgLoRCkj0MsDc9BpquoaYuq0-XwRf_URdXru2JKrVzaWUqQfyKRK76_sQ0aJyVwavM3pPswLlHq2r9032O7Q
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "dpop+jwt",
    "jwk": {
        "kty": "EC",
        "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
        "use": "sig",
        "alg": "EC",
        "crv": "P-256",
        "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
        "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s"
    }
}
```

- `"alg": "ES256"`: The signing algorithm used in this token. In this case, `ES256`
    because we generated the keys using eliptic curves.
- `"typ": "dpop+jwt"`: The type of token. All DPoP Tokens should have a type of "dpop+jwt"
- `"jwk": { "kty": "EC" ... }`: The client's public key.

Token Body:
```json
{
    "htu": "https://secureauth.example/token",
    "htm": "POST",
    "jti": "4ba3e9ef-e98d-4644-9878-7160fa7d3eb8",
    "iat": 1603306128
}
```

- `"htu": "https://secureauth.example/token"`: htu limits the token for use only on the given url.
- `"htm": "POST"`: htm limits the token for use only on a specific http method, in this case `POST`.
- `"jti": "4ba3e9ef-e98d-4644-9878-7160fa7d3eb8"`: jti is a unique identifier for the DPoP token
    that can optionally be used by the server to defend against replay attacks
- `"iat": 1603306128`: The date the token was issued, in this case October 21, 2020 15:52:33 GMT.

<h4 id="authorization-code-pkce-flow-step-14" class="no-num">14. Token request with code and code verifier</h4>

Now, we have everything we need to make an auth request. No need to redirect the web browser
for this one. We only need to make an AJAX request to the `token` endpoint as defined in the
OP's `openid-configuration` file, in our case `https://secureauth.example/token`

```http
POST https://secureauth.example/token
Headers: {
  "DPoP": "eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiZkJ1STExTkdGbTQ4Vlp6RzNGMjVDOVJmMXYtaGdEakVnV2pEQ1BrdV9pVSIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiOWxlT2gxeF9IWkhzVkNScDcyQzVpR01jek1nUnpDUFBjNjBoWldfSFlLMCIsInkiOiJqOVVYcnRjUzRLVzBIYmVteW1vRWlMXzZ1cko0TFFHZXJQZXVNaFNEaV80In19.eyJodHUiOiJodHRwczovL3NlY3VyZWF1dGguZXhhbXBsZS90b2tlbiIsImh0bSI6InBvc3QiLCJqdGkiOiI0YmEzZTllZi1lOThkLTQ2NDQtOTg3OC03MTYwZmE3ZDNlYjgiLCJpYXQiOjE2MDMzMDYxMjgsImV4cCI6MTYwMzMwOTcyOH0.2lbgLoRCkj0MsDc9BpquoaYuq0-XwRf_URdXru2JKrVzaWUqQfyKRK76_sQ0aJyVwavM3pPswLlHq2r9032O7Q",
  "content-type": "application/x-www-form-urlencoded"
}
Body:
  grant_type=authorization_code&
  code_verifier=JXPOuToEB7&
  code=m-OrTPHdRsm8W_e9P0J2Bt&
  redirect_uri=https%3A%2F%2Fdecentphotos.example%2Fcallback&
  client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this
```

- `headers.DPoP: "eyJhbGciOiJFUz..."`: The DPoP token we generated before. This will tell the
    OP what the client's public key is.
- `headers.content-type: "application/x-www-form-urlencoded"`: Sets to body's content type to
    `application/x-www-form-urlencoded`. Some OPs will accept other content types like
    `application/json` but they all must access urlencoded content types, so it's safest to use
    that.
- `body.grant_type=authorization_code`: Tells the OP that we are doing the authorization code
    flow.
- `body.code_verifier=JXPOuToEB7`: Our code verifier that we stored in session storage
- `body.code=m-OrTPHdRsm8W_e9P0J2Bt`: The code that we received from the OP upon redirect
- `body.redirect_uri`: The app's redirect url. In this case, this isn't needed because we're
    doing an AJAX request.
- `body.client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this`: The app's client id.

Once this request is completed decentphotos can remove the code verifier from session storage.

<h4 id="authorization-code-pkce-flow-step-15" class="no-num">15. Validate code verifier</h4>

The OP looks up the code that was saved earlier in a keystore. It checks to see that the client
id in the keystore corresponds to the client id from the request. If it does not, it must
reject the request with a 400 HTTP status and `invalid_grant` error code.

The OP then verifies that the code verifier [corresponds with the code challenge]
(https://tools.ietf.org/html/rfc7636#section-4.6) stored in the keystore.

```bash
BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge
```

If they do not correspond the OP must reject the request with a 400 HTTP status and `invalid_grant`
error code.

<h4 id="authorization-code-pkce-flow-step-16" class="no-num">16. Validates DPoP Token Signature</h4>

The OP extracts the client's public key from the DPoP header (at header.jwk). It confirms that
the DPoP token has a valid signature. If not, the OP must reject the request with a 400 HTTP
status and `invalid_dpop_proof` error code.

<h4 id="authorization-code-pkce-flow-step-17" class="no-num">17. Converts the DPoP public key to a JWK thumbprint</h4>

Currently the DPoP token contains a JWK public key, but before we place it inside the access
token, it needs to be converted into a [JWK thumbprint](https://tools.ietf.org/html/rfc7638).
Our JWK thumbprint looks more like:

```text
9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8
```

<h4 id="authorization-code-pkce-flow-step-19" class="no-num">19. Generates the id_token</h4>

Since `openid` was listed as a scope during the authorization request, the OP generates an id
token. The id token will be pushed as claim to any Solid Authorization Server needed, which clients want to get Access Token from.
This token is a [JSON Web Token](https://jwt.io/introduction/). It would look like
the following (you can decrypt the token with [https://jwt.io](https://jwt.io/#debugger-io?token=eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg)):


Issue: encoded token needs to be updated

```text
eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "JWT"
}
```

 - `"alg": "ES256"`: indicates the token was signed using eliptic curve
 - `"typ": "JWT"`: indicates that this is a JSON web token

Token Body:
```json
{
    "sub": "https://alice.coolpod.example/profile/card#me",
    "aud": [ "solid", "https://decentphotos.example/webid#this"],
    "azp": "https://decentphotos.example/webid#this"
    "webid": "https://alice.coolpod.example/profile/card#me",
    "iss": "https://secureauth.example",
    "jti": "844a095c-9cdb-47e5-9510-1dba987c0a5f",
    "iat": 1603370641,
    "exp": 1603371241,
    "cnf": {
        "jkt": "9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8"
    },
}
```

- `"sub": "https://alice.coolpod.example/profile/card#me"`: The subject claim. It must
    be the same as the authenticated user's WebID.
- `"aud": "https://decentphotos.example/webid#this"`: The token's audience. Because an
    id_token is intended for the client and any Solid Authorization Server,
    its audience is the client id and the string "solid".
- `"azp": "https://decentphotos.example/webid#this"`: The token's authorized party. Because an
    id_token is intended to be used by the client, its authorized party is the client id.
- `"webid": "https://alice.coolpod.example/profile/card#me"`: The WebID of the user that
    logged in
- `"iss": "https://secureauth.example"`: The OP that was used to generate this token
- `"jti": "844a095c-9cdb-47e5-9510-1dba987c0a5f"`: The jti is an optional unique identifier
    for this token that can be used to prevent replay attacks.
- `"iat": 1603370641`: The date the token was issued, in this case October 22, 2020 8:44:01
- `"exp": 1603371241`: The token's expiration date, in this case October 22, 2020 8:54:01
- `"cnf": { "jkt": "9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8" }`: The jwk thrumbprint must
    be embedded in an object on the field "jkt"

<h4 id="authorization-code-pkce-flow-step-20" class="no-num">20. Generates refresh token</h4>

If `offline_access` was provided as a scope, the OP creates an opaque token as
a refresh token. It could be like the one below. Notice the one below is a JWT, but a refresh
token does not need to be a JWT.

```text
eyJhbGciOiJub25lIn0.eyJqdGkiOiJhNzhiNDllZi03MWM1LTQ5ODUtYTUwYy01ZWYzYWVmMGZkOGYifQ.
```

The example token would decrypt as:

Token Header:
```json
{
    "alg": "none"
}
```

Token Body:
```json
{
    "jti": "a78b49ef-71c5-4985-a50c-5ef3aef0fd8f"
}
```

Save the refresh token to a persistant store.

<h4 id="authorization-code-pkce-flow-step-21" class="no-num">21. Sends tokens</h4>

Once the OP has confirmed that everything checks out and all the tokens are generated, it sends
a response with the tokens in the body:

Response (content-type: application/json)
```json
{
    "access_token": "531683bf-fea8-4bca-8976-2de50e5c9a50",
    "id_token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg",
    "refresh_token": "eyJhbGciOiJub25lIn0.eyJqdGkiOiJhNzhiNDllZi03MWM1LTQ5ODUtYTUwYy01ZWYzYWVmMGZkOGYifQ."
}
```

- `"access_token": "531683bf-feea8..."`: The OAuth 2.0 access token, which may be used at the
    OP's `userinfo_endpoint`.
- `"id_token": "eyJhbGciOiJFU..."`: The ID token we generated. The client will use this to
    extract information such as the user's WebId. A client will also exchange the ID token for
    an access token at an authorization server.
- `"refresh_token":	"eyJhbGciOiJ..."`: The refresh token. The client will use this to fetch a
    new ID token when the current token expires.

## Request Flow ## {#request-flow}

<img src="primer-request.mmd.svg" width="980" />


In this example, Alice has logged into `https://decentphotos.example` and has completed the
authentication steps above. She wants to make a request to Bob's Storage to get a photo album
information at `https://bob.otherpod.example/private/photo_album.ttl`. Bob has previously
granted access to Alice but has not granted access to anyone else.

<h4 id="request-flow-step-1" class="no-num">1. Discover Authorization Server</h4>

Client can discover Authorization Server by making request to the resource

Request:
```http
GET https://bob.otherpod.example/private/photo_album.ttl
```

Response:
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="example",
  as_uri="https://auth.otherpod.example",
  ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"
```

<h4 id="request-flow-step-2" class="no-num">2. Request AS configuration</h4>

Knowing Authorization Server now client can discover its Token Endpoint ([[RFC8414]])

Request:
```http
GET https://auth.otherpod.example/.well-known/uma2-configuration
```

Response:
```json
{
    "issuer": "https://auth.otherpod.example",
    "token_endpoint": "https://auth.otherpod.example/token",
    "grant_types_supported": [
        "urn:ietf:params:oauth:grant-type:uma-ticket"
    ]
    ...
}
```

<h4 id="request-flow-step-3" class="no-num">3. Creates a DPoP header token</h4>

Before we request access token, we need to generate a DPoP header token. A new DPoP token must be
generated every time a request is made.

Generating a DPoP token is done the same way we did it in the authentication section. It must be signed by the same keypair that we generated in the authentication section. Our token
could look like the following (you can decode the token using https://jwt.io):
```text
eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiQ21HVE9Dd3ZKWXhrb0dGOGNxcFpBNTdab2xVdThBcFJQb3MwVlduWk1TNCIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiU0FZcmF5VUh4Z1FPQ29YSC1MbHdyOW1iSWJpUHBsLXRQRUpLeE1WWFltcyIsInkiOiJ6eGJQODdPQ3JpeEZpMk9vZjU1QkhsTC1ySHhvWHVuUmttNFBkV3duUzJnIn19.eyJodHUiOiJodHRwczovL2JvYi5vdGhlcnBvZC5leGFtcGxlL3ByaXZhdGUvcGhvdG9fYWxidW0udHRsIiwiaHRtIjoiZ2V0IiwianRpIjoiZmIxMjY0ZGQtZmZmMS00NTA5LWE3YjEtMGZlNThkMDhkM2UxIiwiaWF0IjoxNjAzMzg5NjE2LCJleHAiOjE2MDMzOTMyMTZ9.G8JktoMOadenCYtO4Z_ZI7ACnjKJvT59OyKlQ6WpB1Qq2GoCK6v1ocrpsfELDOKIL5nt5fwWccfvCAA2bMrkjA
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "dpop+jwt",
    "jwk": {
        "kty": "EC",
        "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
        "use": "sig",
        "alg": "EC",
        "crv": "P-256",
        "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
        "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s",
    }
}
```
- `"alg": "ES256"`: The signing algorithm used in this token. In this case, `ES256` because we
    generated the keys using eliptic curves.
- `"typ": "dpop+jwt"`: The type of token. All DPoP Tokens should have a type of "dpop+jwt"
- `"jwk": { "kty": "EC" ... }`: The client's public key.

Token Body:
```json
{
    "htu": "https://auth.otherpod.example/token",
    "htm": "POST",
    "jti": "fb1264dd-fff1-4509-a7b1-0fe58d08d3e1",
    "iat": 1603389616
}
```
- `"htu": "https://auth.otherpod.example/token"`: htu limits the token for
    use only on the given url.
- `"htm": "POST"`: htm limits the token for use only on a specific http method, in this case
    `POST`.
- `"jti": "fb1264dd-fff1-4509-a7b1-0fe58d08d3e1"`: jti is a unique identifier for the DPoP
    token that can optionally be used by the server to defend against replay attacks
- `"iat": 1603389616`: The date the token was issued, in this case October 22, 2020 14:00:16
    GMT.


<h4 id="request-flow-step-4" class="no-num">4. Request Access Token</h4>

Request:
```http
POST /token HTTP/1.1
Host: auth.otherpod.example
DPoP: eyJhbGciOi...
...
grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Auma-ticket
&ticket=016f84e8-f9b9-11e0-bd6f-0021cc6004de
&claim_token=eyj0...
&claim_token_format=http%3A%2F%2Fopenid.net%2Fspecs%2Fopenid-connect-core-1_0.html%23IDToken
```

<h4 id="request-flow-step-5" class="no-num">5. Checks ID Token expirations</h4>

The AS checks if the id token is still valid by looking at the `exp` claim. If the token
does not have an `exp` claim or the token is expired, the AS must reject the request with
a 403 HTTP status. When using UMA 2.0, the AS will include `need_info` and `required_claims`
values in the error response.

<h4 id="request-flow-step-6" class="no-num">6. Checks the DPoP token url and method</h4>

The AS checks the `htu` and `htm` claims of the DPoP token. If the `htu` does not match the
protocol, origin and path of the request or the `htm` does not correspond the the http method
of the request, the AS must reject the request with a 400 HTTP status and an `invalid_dpop_proof`
error code.

<h4 id="request-flow-step-6.1" class="no-num">6.1. (Optional) Checks DPoP token unique identifier</h4>

The AS can optionally keep track of all DPoP `jti` claims it received. Because a new DPoP token
must be generated each time a request is made, no two tokens should have the same `jti`. If the
AS receives a DPoP token with a `jti` it has already encountered it may reject the request with
a 400 HTTP status and an `invalid_dpop_proof` error code.

<h4 id="request-flow-step-7" class="no-num">7. Checks DPoP signature against Access Token</h4>

The AS first confirms that the DPoP token was signed by the public key listed in its `header
jwk`. If it was not, the AS must reject the request with a 400 HTTP status and an
`invalid_dpop_proof` error code.

The AS checks if the public key in the DPoP token's `header.jwk` corresponds to the jwk
thumbprint in the access token in the `cnf` field. If they do not, the OP must reject the
request. When using UMA 2.0, the response will include a 403 HTTP status code and a
`need_info` field in the error response.

<h4 id="request-flow-step-8" class="no-num">8. Retrieves WebID Document</h4>

Using the `webid` claim in the access token (for us, it's
`https://alice.coolpod.example/profile/card#me`), the AS retreives the user's WebId document.

Request
```http
GET https://alice.coolpod.example/profile/card#me
```

Response
```ttl
@prefix : <#>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix schema: <http://schema.org/>.

<>
    a foaf:PersonalProfileDocument ;
    foaf:maker <https://localhost:8443/profile/card#me> ;
    foaf:primaryTopic <https://localhost:8443/profile/card#me> .

:me a foaf:Person ;
    a schema:Person ;
    foaf:name "Alice" ;
    solid:oidcIssuer <https://secureauth.example> ;
```

<h4 id="request-flow-step-9" class="no-num">9. Checks issuer</h4>

The AS checks that the `iss` claim in the ID token matches the issuer listed in the user's
WebID. If it does not, the AS must reject the request.

<h4 id="request-flow-step-10" class="no-num">10. Retrieves OP configuration</h4>

The AS uses the `iss` claim to get the issuer's configuration. The url is the issuer claim with
`/.well-known/openid-configuration` appended to the end.

Request
```http
GET https://secureauth.example/.well-known/openid-configuration
```

Response
```json
{
    "issuer": "https://secureauth.example",
    "authorization_endpoint": "https://secureauth.example/authorize",
    "token_endpoint": "https://secureauth.example/token",
    "userinfo_endpoint": "https://secureauth.example/userinfo",
    "registration_endpoint": "https://secureauth.example/register",
    "end_session_endpoint": "https://secureauth.example/endsession",
    "jwks_uri": "https://secureauth.example/jwks",
    "response_types_supported": [
        "code"
    ],
    "grant_types_supported": [
        "authorization_code",
        "refresh_token"
    ],
    "subject_types_supported": [
        "public"
    ],
    "claims_supported": [
        "sub",
        "webid"
    ],
    "scopes_supported": [
        "openid",
        "webid",
        "profile",
        "email",
        "offline_access"
    ],
    "token_endpoint_auth_methods_supported": [
        "client_secret_basic"
    ],
    "token_endpoint_auth_signing_alg_values_supported": [
        "ES256"
    ],
    "request_object_signing_alg_values_supported": [
        "ES256"
    ],
    "id_token_signing_alg_values_supported": [
        "ES256"
    ],
    "code_challenge_methods_supported": [
        "plain",
        "S256"
    ],
    "claims_parameter_supported": false,
    "request_parameter_supported": true,
    "request_uri_parameter_supported": false,
    "require_request_uri_registration": false
}
```

<h4 id="request-flow-step-11" class="no-num">11. Requests JWKS</h4>

Using the `jwks_uri` field in the openid-configuration, the AS makes a request to retreive the
OP's public keys.

Request
```http
GET https://secureauth.example/jwks
```

Response (application/json)
```json
{
    "keys": [
        {
            "alg": "EC",
            "crv": "P-256",
            "kid": "Xu68Q0ZfwDiRfWOb2UE8N77GoEQQ7q58_3gl1wsKENs",
            "kty": "EC",
            "use": "sig",
            "x": "qBbrIQNVTIm7M88iJFVB3e1GqsbFbYYfFiibkd48_Ac",
            "y": "SCl_hDR_6SEuJhKFOiVo8-zLqNglZ56jiJw2_PNE9hU"
        }
    ]
}
```

Notice that the `keys` field is an array, so an OP could have multiple public keys.

<h4 id="request-flow-step-12" class="no-num">12. Checks ID token signature validity</h4>

Using the `kid` value in the ID token, the AS searches the OP public keys for one that matches the
one used to sign the ID token. If no public key is found, the AS must reject the request.

<h4 id="request-flow-step-13" class="no-num">13. Access Token Response</h4>

Now that the AS has performed all of its checks, we can trust that the agent in the `webid`
claim (`https://alice.coolpod.example/profile/card#me`) is the same agent on whose behalf the
request was made. Using that information, the AS performs authorization and returns access token.

Response:
```json
{
   "access_token":"sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv",
   "token_type":"Bearer"
}
```

<h4 id="request-flow-step-14" class="no-num">14. Sends request with Access Token</h4>

Note: In practice client would need to upgrade RPT by pushing
authorization related claim. This primer only focuses on authentication so we omit
this detail here.

With the access token, we're ready to make our request.

```http
GET https://bob.otherpod.example/private/photo_album.ttl
Headers: {
    authorization: "Bearer sbjsbhs(/SSJHBSUSSJHVhjsgvhsgvshgsv",
}
```

<h4 id="request-flow-step-15" class="no-num">15. Returns Result</h4>

Given all went well, the RS should return the requested content.

<pre class=biblio>
{
    "OIDC.Core": {
        "authors": [
            "N. Sakimura",
            "J. Bradley",
            "M.B. Jones",
            "B. de Medeiros",
            "C. Mortimore"
        ],
        "href": "https://openid.net/specs/openid-connect-core-1_0.html",
        "title": "OpenID Connect Core 1.0",
        "publisher": "The OpenID Foundation"
    },
    "Solid.Protocol": {
        "authors": [
            "Sarven Capadisli",
            "Tim Berners-Lee",
            "Ruben Verborgh",
            "Kjetil Kjernsmo",
            "Justin Bingham",
            "Dmitri Zagidulin"
        ],
        "href": "https://solidproject.org/TR/protocol",
        "title": "Solid Protocol",
        "publisher": "W3C Solid Community Group"
    },
    "Solid.OIDC": {
        "authors": [
            "Aaron Coburn",
            "elf Pavlik ",
            "Dmitri Zagidulin"
        ],
        "href": "https://solid.github.io/solid-oidc/",
        "title": "Solid OIDC",
        "publisher": "W3C"
    },
    "WebID": {
        "authors": [
            "Andrei Sambra",
            "Henry Story",
            "Tim Berners-Lee"
        ],
        "href": "https://www.w3.org/2005/Incubator/webid/spec/identity/",
        "title": "WebID 1.0",
        "publisher": "WebID Incubator Group"
    }
}
</pre>
