<pre class='metadata'>
Title: Solid OIDC Primer
Boilerplate: issues-index no
Boilerplate: style-darkmode off
Boilerplate: repository-issue-tracking off
Shortname: solid-oidc-primer
Level: 1
Status: w3c/ED
Group: Solid Community Group
ED: https://solid.github.io/authentication-panel/solid-oidc/primer.html
TR: https://solid.github.io/authentication-panel/solid-oidc/
Repository: https://github.com/solid/specification
Issue Tracking: GitHub Issues https://github.com/solid/specification/issues/
Markup Shorthands: markdown yes
Max ToC Depth: 2
Editor: [Jackson Morgan](https://github.com/jaxoncreed)
Editor: [Aaron Coburn](https://github.com/acoburn)
Editor: [Matthieu Bosquet](https://github.com/matthieubosquet)
Abstract:
  The Solid OpenID Connect (Solid OIDC) specification defines how resource servers
  verify the identity of relying parties and end users based on the authentication
  performed by an OpenID provider. Solid OIDC builds on top of OpenID Connect 1.0.
  This primer is designed to provide the reader with the basic knowledge required
  to understand Solid OpenID Connect authentication flows. It introduces the basic
  concepts of authentication in the Solid ecosystem.
</pre>

# Introduction # {#intro}

This document outlines in details how Alice (end-user) asserts her identity
(logs in) when using Decent Photos (relying party) to access data in hers and
Bob's Solid Data Pods (resource servers).

# Definitions # {#definitions}

<dl>
  <dt id="openid-provider">OpenID Provider (OP)</dt>
  <dd>An OAuth 2.0 authorization server implementing OpenID Connect as defined in the OpenID Connect Core 1.0 specification. [[!OpenIDConnect]]</dd>
  <dt id="relying-party">Relying Party (RP)</dt>
  <dd>A client application using OpenID Connect to make resource requests on behalf of the resource owner. Client is one of the four roles [defined in the OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-1.1). [[!RFC6749]]</dd>
  <dt id="resource">Resource</dt>
  <dd>Something denoted by an IRI or a literal as [defined in RDF 1.1](https://www.w3.org/TR/rdf11-concepts/#resources-and-statements). [[!rdf11-concepts]]</dd>
  <dt id="resource-owner">Resource Owner</dt>
  <dd>An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. Resource Owner is one of the four roles [defined in the OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-1.1). [[!RFC6749]]</dd>
  <dt id="resource-server">Resource Server (RS)</dt>
  <dd>A server hosting resources, capable of accepting and responding to protected resource requests using access tokens. RS is one of the four roles [defined in the OAuth 2.0 specification](https://tools.ietf.org/html/rfc6749#section-1.1). [[!RFC6749]]</dd>
  <dt id="solid-data-pod">Solid Data Pod (Pod)</dt>
  <dd>A Solid compliant Resource Server as [defined in the Solid Specification](https://solid.github.io/specification/#data-pod). [[!Solid]]</dd>
  <dt id="solid-oidc">Solid OpenID Connect (Solid OIDC)</dt>
  <dd>The specification defining authentication in the Solid ecosystem. [[!SolidOIDC]]</dd>
  <dt id="webid">WebID</dt>
  <dd>A WebID is an HTTP URI which refers to an Agent (Person, Organization, Group, Device, etc.) as [defined in the WebID 1.0 specification](https://dvcs.w3.org/hg/WebID/raw-file/tip/spec/identity-respec.html#introduction). [[!WebID]]</dd>
</dl>

# Actors # {#actors}

Several actors are at play in our example Solid OIDC authentication flows:

<dl>
  <dt id="alice">Alice</dt>
  <dd>Alice will be providing consent for Decent Photos to make resource requests
 on her behalf. Let's assume that Alice is using a standard web browser.</dd>
  <dt id="alice-op">Alice's OP</dt>
  <dd>Alice's OpenID Provider, also known as an Identity Provider (IdP), is the
 service responsible for authorizing our third-party web app (Decent Photos) by
 providing it with the tokens necessary to gain access to any resource Alice has
 access to (in any Pod, for example Alice's and Bob's). In our example, Alice's
 OP is hosted at `https://secureauth.example`.</dd>
  <dt id="alice-webid">Alice's WebID</dt>
  <dd>Alice's WebID is `https://alice.coolpod.example/profile/card#me`. The WebID
 profile document denoted by URI `https://alice.coolpod.example/profile/card` is
 hosted on Alice's Solid Data Pod and contains the URI of her OP. Alice's WebID
 `https://alice.coolpod.example/profile/card#me` serves as her unique identifier
 in the Solid Ecosystem.</dd>
  <dt id="rp">RP</dt>
  <dd>The Decent Photos application is a third party photo viewing web application.
 It is OIDC compliant and will therefore be referred to as the Relying Party. The
 Decent Photos web app allows its users to view photos they have access to. For
 example, Alice's and her friend Bob's photos. In our example, Decent Photos is
 hosted at `https://decentphotos.example`.</dd>
  <dt id="decentphotos-rp-webid">RP's WebID</dt>
  <dd>Decent Photos is a Solid compliant application and has a WebID of its own. An
 RP's WebID contains information identifying them as a registered OAuth 2.0 client
 application. Decent Photo's WebID is `https://decentphotos.example/webid#this`</dd>
  <dt id="bob-pod">Bob's Pod</dt>
  <dd>We will be trying to access photos stored in Bob's Pod. In our example, Bob
 is a friend of Alice and has previously indicated via access control that Alice
 may access some of his photos using any web app. Bob's Solid Data Pod is hosted at
 `https://bob.otherpod.example`.</dd>
</dl>

# Solid OIDC Flow # {#solid-oidc-flow}

## Authorization Code Grant with PKCE Authorization Flow ## {#authorization-code-pkce-flow}

The Authorization Code grant with PKCE is the primary OAuth 2.0 authorization flow 
recommended by the Solid OIDC. It is defined by the PKCE RFC [[!RFC7636]] and 
described here in the Solid OIDC context.

<img src="primer-login.mmd.svg" width="980" />

<h4 id="authorization-code-pkce-flow-step-1" class="no-num">1. Alice uses the Decent Photos web app</h4>

Alice has heard of a great new site that allows her to view her friend's photos and tag faces.
She navigates to `https://decentphotos.example` via her web browser which returns an HTML page.
This page contains JavaScript that will help with the authentication process.

<h4 id="authorization-code-pkce-flow-step-2" class="no-num">2. Alice selects her OP or WebID</h4>

Before decentphotos can start displaying images, Alice needs to start the
process of providing consent. To do so, she must either provide her WebID
(`https://alice.coolpod.example/profile/card#me`) or the URL of her OP
(`https://secureauth.example`).

Although it is not the case for Alice, a user's Pod and OP can be hosted under the
same domain. For example, Bob could have a Pod at `https://bob.solidpod.example.com`,
an OP at `https://solidpod.example.com/`, and a WebID of
`https://bob.solidpod.example.com/profile/card#me`.

<h4 id="authorization-code-pkce-flow-step-2.1" class="no-num">2.1 Retrieve Profile (only needed if a WebID is provided)</h4>

If Alice enters her WebID's URL rather than her OP's URL, a request should be
made to determine her OP. To do so, a request should be made to Alice's WebId:

```http
GET https://alice.coolpod.example/profile/card#me
```

It will return a body similar to this:

```ttl
@prefix : <#>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix schema: <http://schema.org/>.

<>
    a foaf:PersonalProfileDocument ;
    foaf:maker <https://localhost:8443/profile/card#me> ;
    foaf:primaryTopic <https://localhost:8443/profile/card#me> .

:me a foaf:Person ;
    a schema:Person ;
    foaf:name "Alice" ;
    solid:oidcIssuer <https://secureauth.example> ;
```

The OP URL is located at `:me -> solid:oidcIssuer`

<h4 id="authorization-code-pkce-flow-step-3" class="no-num">3. Retrieves OP Configuration</h4>

Now that we have Alice's OP's URL, the RP must make a request to retrieve the
OP's configuration. This is always located at the OP's issuer URL followed by
`/.well-known/openid-configuration`.

```http
GET https://secureauth.example/.well-known/openid-configuration
```

The [openid-configuration](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata)
describes everything the client will need to know to authorize with Alice's specific OP.

Response Body:
```json
{
    "issuer": "https://secureauth.example",
    "authorization_endpoint": "https://secureauth.example/authorize",
    "token_endpoint": "https://secureauth.example/token",
    "userinfo_endpoint": "https://secureauth.example/userinfo",
    "registration_endpoint": "https://secureauth.example/register",
    "end_session_endpoint": "https://secureauth.example/endsession",
    "jwks_uri": "https://secureauth.example/jwks",
    "solid_oidc_supported": "https://solidproject.org/TR/solid-oidc",
    "response_types_supported": [
        "code"
    ],
    "grant_types_supported": [
        "authorization_code",
        "refresh_token"
    ],
    "subject_types_supported": [
        "public"
    ],
    "claims_supported": [
        "sub",
        "webid"
    ],
    "scopes_supported": [
        "openid",
        "profile",
        "email",
        "offline_access"
    ],
    "token_endpoint_auth_methods_supported": [
        "client_secret_basic"
    ],
    "token_endpoint_auth_signing_alg_values_supported": [
        "ES256"
    ],
    "request_object_signing_alg_values_supported": [
        "ES256"
    ],
    "id_token_signing_alg_values_supported": [
        "ES256"
    ],
    "code_challenge_methods_supported": [
        "plain",
        "S256"
    ],
    "claims_parameter_supported": false,
    "request_parameter_supported": true,
    "request_uri_parameter_supported": false,
    "require_request_uri_registration": false
}
```

The thing we care about here is the `authorization_endpoint` field. This will
be the url we use when we're ready to send an authorization request to the OP.

Note that we only support the `code` response type. The OIDC discovery
specification states that Dynamic OpenID Providers MUST also support
`id_token` and `token id_token`. However, [implicit flows should not be used for
security reasons](https://oauth.net/2/grant-types/implicit/). Therefore, we
don't recommend enabling them. For the same reason, we do not support the
`implicit` grant type.

<h4 id="authorization-code-pkce-flow-step-4" class="no-num">4. Generates PKCE code challenge and code verifier</h4>

To follow the [PKCE code flow](https://oauth.net/2/pkce/) we need to generate a
code challenge and code verifier as instructed in the [Proof Key for Code
Exchange spec](https://tools.ietf.org/html/rfc7636#section-4.1).

We start by generating a code verifier. The can be done by creating a
cryptographically random string. Let's say ours looks like this: `"JXPOuToEB7"`.

Now using the code verifier, we construct a code challenge. This can be made by transforming
the code verifier with Sha 256: `BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))`. Here's our
code challenge: `"HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0"`

<h4 id="authorization-code-pkce-flow-step-5" class="no-num">5. Saved code verifier to session storage</h4>

Now, we save the code verifier (`"JXPOuToEB7"`) to session storage. We'll need it later to
confirm to the OP that this is the app that initiated the request. Do not save the code
challenge anywhere.

<h4 id="authorization-code-pkce-flow-step-6" class="no-num">6. Authorization request</h4>

Now that the web app is registered, we can finally make an auth request to authorize the web
application.

```http
GET https://secureauth.example/authorize?response_type=code&
redirect_uri=https%3A%2F%2Fdecentphotos.example%2Fcallback&
scope=openid%20profile%20offline_access&
client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this&
code_challenge_method=S256&
code_challenge=HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0
```

That URL might look a little complex, but it's essentially a request to
`https://secureauth.example/authorize` with the following URL parameters:

- `response_type=code` indicates the desired response data.
- `redirect_uri=https%3A%2F%2Fdecentphotos.example%2Fcallback`:
    The url that the OP will redirect to once the user has logged in (`https://decentphotos.example/callback`).
- `scope=openid%20profile%20offline_access`: a list of [OIDC scopes](https://auth0.com/docs/scopes/current/oidc-scopes) 
    (attributes of the RS to which this token should have access) separated by spaces (%20). 
    - `openid` is a scope that is needed to verify Alice's identity.
    - `profile` is required by the Solid OIDC specification to denote a WebID login.
    - `offline_access`: Is required to get a refresh token.
- `client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this`: Usually the client id of a Solid 
    application is the app's WebID (in our case `https://decentphotos.example/webid#this`) as seen here.
- `code_challenge_method=S256`: Tells the OP that our code challenge was transformed using SHA-256.
- `code_challenge=HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0`: The code challenge we generated before.

Note: If the app doesn't have a WebID, you can either register an app using static registration
via some UI on the OP or [dynamic registration](https://openid.net/specs/openid-connect-registration-1_0.html).
You may also use `http://www.w3.org/ns/solid/terms#PublicOidcClient` as your client id. This will designate the
client as a public client. Doing this may cause the RS to provide less access to your app.

<h4 id="authorization-code-pkce-flow-step-7" class="no-num">7. Fetch RP WebID</h4>

If an app WebID is provided as the client id (see note above to see other options), we must
fetch that app WebID to confirm its validity.

For the WebID `https://decentphotos.example/webid#this`, request the WebID Profile with:
```http
GET https://decentphotos.example/webid
```

Response:
```ttl
@prefix solid:  .

<#this> solid:oidcRegistration """{
    "client_id": "https://decentphtos.example/webid#this",
    "redirect_uris": [ "https://decentphotos.example/callback" ],
    "client_name": "DecentPhotos",
    "client_uri": "https://decentphotos.example/",
    "logo_uri": "https://decentphotos.example/logo.png",
    "tos_uri": "https://decentphotos.example/tos.html",
    "scope": "openid profile offline_access",
    "grant_types": [ "refresh_token", "authorization_code" ],
    "response_types": [ "code" ],
    "default_max_age": 60000,
    "require_auth_time": true
    }""" .
```

Notice that the application WebID contains one required triple `?webid solid:oidcRegistration 
jsonRegistration`. This is a JSON representation of an
[OIDC Client Registration](https://tools.ietf.org/html/rfc7591#section-2).

<h4 id="authorization-code-pkce-flow-step-8" class="no-num">8. Validate redirect url with WebID</h4>

Check to be sure that the `redirect_uri` value provided in the auth request
(`https://decentphotos.example/callback`) is listed in the `redirect_uris` array in the
oidcRegistration. If it is not, the OP MUST reject the request with a `403`. In our case, it
is, so we may continue.

<h4 id="authorization-code-pkce-flow-step-9" class="no-num">9. Alice Logs In</h4>

The OP should redirect to its login screen. The actual implementation of this is completely up
to the OP. A user can log in with her password, a TLS certificate, or any other proven method
of authentication. The important thing is that, thanks to the redirect, the control is now out
of the hands of the RP and is in complete control of the OP.

<h4 id="authorization-code-pkce-flow-step-10" class="no-num">10. Generate a code</h4>

Generate a cryptographically random string that will be used as a code (Let's say ours is
`m-OrTPHdRsm8W_e9P0J2Bt`). Store that string in a persistant keystore as the key for the client
id, the code challenge, the user's webid, their desired response types, and their scopes:

```json
{
  "m-OrTPHdRsm8W_e9P0J2Bt": {
    "client_id": "https://decentphotos.example/webid#this",
    "code_challenge": "HSi9dwlvRpNHCDm-L8GOdM16qcb0tLHPZqQSvaWXTI0",
    "webid": "https://alice.coolpod.example/profile/card#me",
    "response_types": [ "code" ],
    "scope": [ "openid", "profile", "offline_access" ]
  }
}
```

<h4 id="authorization-code-pkce-flow-step-11" class="no-num">11. Send code to redirect url</h4>

Once Alice successfully logs in, the OP redirects back to the application via the provided
redirect uri, including useful information with it:

```http
302 redirect to: https://decentphotos.example/callback?code=m-OrTPHdRsm8W_e9P0J2Bt
```

This redirect gives decentphotos the code that it will exchange for an access token.

<h4 id="authorization-code-pkce-flow-step-12" class="no-num">12. Generates a DPoP Client Key Pair</h4>

Solid-OIDC depends on
[Demonstration of Proof-of-Possession (DPoP) tokens](https://tools.ietf.org/html/draft-ietf-oauth-dpop-03).
DPoP tokens ensure that third-party web applications can send requests to any number of
Pods while ensuring that evil Pods can't steal a user's token.

The first step to generating a DPoP token is generating a public and private key pair on the
third-party RP. In our example, the private key is generated using elliptic curves and looks
like:

```json
{
    "kty": "EC",
    "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
    "use": "sig",
    "alg": "EC",
    "crv": "P-256",
    "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
    "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s",
    "d": "RrM4Ou_7PzjP24B4k06B9ZML16HbfzNPKFN11Z8c9_s"
}
```

From now on we will refer to this as `RP_PRIVATE_KEY`.

The public key looks like:
```json
{
    "kty": "EC",
    "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
    "use": "sig",
    "alg": "EC",
    "crv": "P-256",
    "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
    "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s"
}
```

<h4 id="authorization-code-pkce-flow-step-13" class="no-num">13. Generates a DPoP Header</h4>

Now that we generated a private key for the client, we need to generate the DPoP header. To do
so, we create a [JSON Web Token](https://jwt.io/introduction/) and sign it using the key we
generated.

Our token could look like the following (you can decode the token using https://jwt.io):
```text
eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiZkJ1STExTkdGbTQ4Vlp6RzNGMjVDOVJmMXYtaGdEakVnV2pEQ1BrdV9pVSIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiOWxlT2gxeF9IWkhzVkNScDcyQzVpR01jek1nUnpDUFBjNjBoWldfSFlLMCIsInkiOiJqOVVYcnRjUzRLVzBIYmVteW1vRWlMXzZ1cko0TFFHZXJQZXVNaFNEaV80In19.eyJodHUiOiJodHRwczovL3NlY3VyZWF1dGguZXhhbXBsZS90b2tlbiIsImh0bSI6InBvc3QiLCJqdGkiOiI0YmEzZTllZi1lOThkLTQ2NDQtOTg3OC03MTYwZmE3ZDNlYjgiLCJpYXQiOjE2MDMzMDYxMjgsImV4cCI6MTYwMzMwOTcyOH0.2lbgLoRCkj0MsDc9BpquoaYuq0-XwRf_URdXru2JKrVzaWUqQfyKRK76_sQ0aJyVwavM3pPswLlHq2r9032O7Q
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "dpop+jwt",
    "jwk": {
        "kty": "EC",
        "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
        "use": "sig",
        "alg": "EC",
        "crv": "P-256",
        "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
        "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s"
    }
}
```

- `"alg": "ES256"`: The signing algorithm used in this token. In this case, `ES256` 
    because we generated the keys using eliptic curves.
- `"typ": "dpop+jwt"`: The type of token. All DPoP Tokens should have a type of "dpop+jwt"
- `"jwk": { "kty": "EC" ... }`: The client's public key.

Token Body:
```json
{
    "htu": "https://secureauth.example/token",
    "htm": "POST",
    "jti": "4ba3e9ef-e98d-4644-9878-7160fa7d3eb8",
    "iat": 1603306128
}
```

- `"htu": "https://secureauth.example/token"`: htu limits the token for use only on the given url.
- `"htm": "POST"`: htm limits the token for use only on a specific http method, in this case `POST`.
- `"jti": "4ba3e9ef-e98d-4644-9878-7160fa7d3eb8"`: jti is a unique identifier for the DPoP token 
    that can optionally be used by the server to defend against replay attacks
- `"iat": 1603306128`: The date the token was issued, in this case October 21, 2020 15:52:33 GMT.

<h4 id="authorization-code-pkce-flow-step-14" class="no-num">14. Token request with code and code verifier</h4>

Now, we have everything we need to make an auth request. No need to redirect the web browser
for this one. We only need to make an AJAX request to the `token` endpoint as defined in the
OP's `openid-configuration` file, in our case `https://secureauth.example/token`

```http
POST https://secureauth.example/token
Headers: {
  "DPoP": "eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiZkJ1STExTkdGbTQ4Vlp6RzNGMjVDOVJmMXYtaGdEakVnV2pEQ1BrdV9pVSIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiOWxlT2gxeF9IWkhzVkNScDcyQzVpR01jek1nUnpDUFBjNjBoWldfSFlLMCIsInkiOiJqOVVYcnRjUzRLVzBIYmVteW1vRWlMXzZ1cko0TFFHZXJQZXVNaFNEaV80In19.eyJodHUiOiJodHRwczovL3NlY3VyZWF1dGguZXhhbXBsZS90b2tlbiIsImh0bSI6InBvc3QiLCJqdGkiOiI0YmEzZTllZi1lOThkLTQ2NDQtOTg3OC03MTYwZmE3ZDNlYjgiLCJpYXQiOjE2MDMzMDYxMjgsImV4cCI6MTYwMzMwOTcyOH0.2lbgLoRCkj0MsDc9BpquoaYuq0-XwRf_URdXru2JKrVzaWUqQfyKRK76_sQ0aJyVwavM3pPswLlHq2r9032O7Q",
  "content-type": "application/x-www-form-urlencoded"
}
Body:
  grant_type=authorization_code&
  code_verifier=JXPOuToEB7&
  code=m-OrTPHdRsm8W_e9P0J2Bt&
  redirect_uri=https%3A%2F%2Fdecentphotos.example%2Fcallback&
  client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this
```

- `headers.DPoP: "eyJhbGciOiJFUz..."`: The DPoP token we generated before. This will tell the
    OP what the client's public key is.
- `headers.content-type: "application/x-www-form-urlencoded"`: Sets to body's content type to
    `application/x-www-form-urlencoded`. Some OPs will accept other content types like
    `application/json` but they all must access urlencoded content types, so it's safest to use
    that.
- `body.grant_type=authorization_code`: Tells the OP that we are doing the authorization code
    flow.
- `body.code_verifier=JXPOuToEB7`: Our code verifier that we stored in session storage
- `body.code=m-OrTPHdRsm8W_e9P0J2Bt`: The code that we received from the OP upon redirect
- `body.redirect_uri`: The app's redirect url. In this case, this isn't needed because we're
    doing an AJAX request.
- `body.client_id=https%3A%2F%2Fdecentphotos.example%2Fwebid%23this`: The app's client id.

Once this request is completed decentphotos can remove the code verifier from session storage.

<h4 id="authorization-code-pkce-flow-step-15" class="no-num">15. Validate code verifier</h4>

The OP looks up the code that was saved earlier in a keystore. It checks to see that the client
id in the keystore corresponds to the client id from the request. If it does not, it must
reject the request with a 403.

The OP then verifies that the code verifier [corresponds with the code challenge]
(https://tools.ietf.org/html/rfc7636#section-4.6) stored in the keystore. 

```bash
BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge
```

If they do not correspond the OP must reject the request with a 403.

<h4 id="authorization-code-pkce-flow-step-16" class="no-num">16. Validates DPoP Token Signature</h4>

The OP extracts the client's public key from the DPoP header (at header.jwk). It confirms that
the DPoP token has a valid signature. If not, the OP must reject the request with a 403.

<h4 id="authorization-code-pkce-flow-step-17" class="no-num">17. Converts the DPoP public key to a JWK thumbprint</h4>

Currently the DPoP token contains a JWK public key, but before we place it inside the access
token, it needs to be converted into a [JWK thumbprint](https://tools.ietf.org/html/rfc7638).
Our JWK thumbprint looks more like:

```text
9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8
```

<h4 id="authorization-code-pkce-flow-step-18" class="no-num">18. Generates access token</h4>

The OP generates an access token. To do so it constructs a JSON Web Token and signs it using
its own keys. The access token could look like (remember you can decode it using 
[https://jwt.io](https://jwt.io/#debugger-io?token=eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwiYXVkIjoic29saWQiLCJjbmYiOnsiamt0IjoiOVhtd0s4bVEzSDUtUG56QXQzbEZIeldCV192NVFoWXluZXpiYml0NGtDOCJ9LCJjbGllbnRfaWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJqdGkiOiJmZDBhMTM1My0yNWYzLTRjN2UtOGY4Yi1jMTQyNjRmMWMxMmUiLCJpYXQiOjE2MDMzODUyNjEsImV4cCI6MTYwMzM4NTg2MX0.HIIYiovILPvsdkD3s3xomR1MkA_Ir8Mx_C-eHxbWEnw9Z2rv2rOWbvMPZ--BqH3qVSupgYTZZsTDbZXA8giCLA)):

```text
eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwiYXVkIjoic29saWQiLCJjbmYiOnsiamt0IjoiOVhtd0s4bVEzSDUtUG56QXQzbEZIeldCV192NVFoWXluZXpiYml0NGtDOCJ9LCJjbGllbnRfaWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJqdGkiOiJmZDBhMTM1My0yNWYzLTRjN2UtOGY4Yi1jMTQyNjRmMWMxMmUiLCJpYXQiOjE2MDMzODUyNjEsImV4cCI6MTYwMzM4NTg2MX0.HIIYiovILPvsdkD3s3xomR1MkA_Ir8Mx_C-eHxbWEnw9Z2rv2rOWbvMPZ--BqH3qVSupgYTZZsTDbZXA8giCLA
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "JWT"
}
```

 - `"alg": "ES256"`: indicates the token was signed using eliptic curve
 - `"typ": "JWT"`: indicates that this is a JSON web token

Token Body:
```json
{
    "webid": "https://alice.coolpod.example/profile/card#me",
    "iss": "https://secureauth.example",
    "aud": "solid",
    "cnf": {
        "jkt": "9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8"
    },
    "client_id": "https://decentphotos.example/webid#this",
    "jti": "fd0a1353-25f3-4c7e-8f8b-c14264f1c12e",
    "iat": 1603385261,
    "exp": 1603385861
}
```

- `"webid": "https://alice.coolpod.example/profile/card#me"`: The WebId of the user that
    logged in
- `"iss": "https://secureauth.example"`: The OP that was used to generate this token
- `"aud": "solid"`: The token's audience. Because DPoP handles scoping the audience in all
    practical senses, the audience for a solid token is simply "solid."
- `"cnf": { "jkt": "9XmwK8mQ3H5-PnzAt3lFHzWBW_v5QhYynezbbit4kC8" }`: The jwk thrumbprint must
    be embedded in an object on the field "jkt"
- `"client_id": "https://decentphotos.example/webid#this"`: The client id of the application
- `"iat": 1603370641`: The date the token was issued, in this case October 22, 2020 8:44:01
- `"exp": 1603371241`: The token's expiration date, in this case October 22, 2020 8:54:01

<h4 id="authorization-code-pkce-flow-step-19" class="no-num">19. Generates the id_token</h4>

If `openid` was listed as a scope during the authorization request, the OP generates an id
token. The id token is not used to access anything. It is simply to communicate information to
the client. This token is a [JSON Web Token](https://jwt.io/introduction/). It would look like
the following (you can decrypt the token with [https://jwt.io](https://jwt.io/#debugger-io?token=eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg)):

```text
eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "JWT"
}
```

 - `"alg": "ES256"`: indicates the token was signed using eliptic curve
 - `"typ": "JWT"`: indicates that this is a JSON web token

Token Body:
```json
{
    "sub": "https://alice.coolpod.example/profile/card#me",
    "aud": "https://decentphotos.example/webid#this",
    "webid": "https://alice.coolpod.example/profile/card#me",
    "iss": "https://secureauth.example",
    "jti": "844a095c-9cdb-47e5-9510-1dba987c0a5f",
    "iat": 1603370641,
    "exp": 1603371241
}
```

- `"sub": "https://alice.coolpod.example/profile/card#me"`: The subject claim. It must
    be the same as the authenticated user's WebID.
- `"aud": "https://decentphotos.example/webid#this"`: The token's audience. Because an
    id_token is intended for the client, its audience is the client id.
- `"webid": "https://alice.coolpod.example/profile/card#me"`: The WebID of the user that
    logged in
- `"iss": "https://secureauth.example"`: The OP that was used to generate this token
- `"jti": "844a095c-9cdb-47e5-9510-1dba987c0a5f"`: The jti is an optional unique identifier
    for this token that can be used to prevent replay attacks.
- `"iat": 1603370641`: The date the token was issued, in this case October 22, 2020 8:44:01
- `"exp": 1603371241`: The token's expiration date, in this case October 22, 2020 8:54:01

<h4 id="authorization-code-pkce-flow-step-20" class="no-num">20. Generates refresh token</h4>

If `offline_access` was provided as a scope, the OP creates an opaque token as
a refresh token. It could be like the one below. Notice the one below is a JWT, but a refresh
token does not need to be a JWT.

```text
eyJhbGciOiJub25lIn0.eyJqdGkiOiJhNzhiNDllZi03MWM1LTQ5ODUtYTUwYy01ZWYzYWVmMGZkOGYifQ.
```

The example token would decrypt as:

Token Header:
```json
{
    "alg": "none"
}
```

Token Body:
```json
{
    "jti": "a78b49ef-71c5-4985-a50c-5ef3aef0fd8f"
}
```

Save the refresh token to a persistant store.

<h4 id="authorization-code-pkce-flow-step-21" class="no-num">21. Sends tokens</h4>

Once the OP has confirmed that everything checks out and all the tokens are generated, it sends
a response with the tokens in the body:

Response (content-type: application/json)
```json
{
    "access_token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwiYXVkIjoic29saWQiLCJjbmYiOnsiamt0IjoiOVhtd0s4bVEzSDUtUG56QXQzbEZIeldCV192NVFoWXluZXpiYml0NGtDOCJ9LCJjbGllbnRfaWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJqdGkiOiJmZDBhMTM1My0yNWYzLTRjN2UtOGY4Yi1jMTQyNjRmMWMxMmUiLCJpYXQiOjE2MDMzODUyNjEsImV4cCI6MTYwMzM4NTg2MX0.HIIYiovILPvsdkD3s3xomR1MkA_Ir8Mx_C-eHxbWEnw9Z2rv2rOWbvMPZ--BqH3qVSupgYTZZsTDbZXA8giCLA",
    "expires_in": 300,
    "token_type": "DPoP",
    "id_token": "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJhdWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwianRpIjoiODQ0YTA5NWMtOWNkYi00N2U1LTk1MTAtMWRiYTk4N2MwYTVmIiwiaWF0IjoxNjAzMzg2NDQ4LCJleHAiOjE2MDMzODcwNDh9.T306vT8dmn9gQIMEdG92AM4WRnrhqWZTfDpovwqZ6Zn0mK9yxj0iOVGqXD4CW8-tzDTitNwEGorAo85atL0Oeg",
    "refresh_token": "eyJhbGciOiJub25lIn0.eyJqdGkiOiJhNzhiNDllZi03MWM1LTQ5ODUtYTUwYy01ZWYzYWVmMGZkOGYifQ.",
    "scope": "openid profile offline_access"
}
```

- `access_token": "eyJhbGciOiJ..."`: The access token we generated. The client will use this
    to authenticate with the server.
- `"expires_in":	300`: Tells the client that the access token will expire in 300 seconds (5
    minutes)
- `"token_type":	"DPoP"`: Tells the client that the token type is DPoP
- `"id_token": "eyJhbGciOiJFU..."`: The id token we generated. The client will use this to
    extract information like the user's WebId.
- `"refresh_token":	"eyJhbGciOiJ..."`: The refresh token. The client will use this to get a
    new access token when its current one expires.
- `"scope":	"openid profile offline_access"`: The scopes that were used.

## Request Flow ## {#request-flow}

<img src="primer-request.mmd.svg" width="980" />

<h4 id="request-flow-step-1" class="no-num">1. An AJAX request is initiated</h4>

In this example, Alice has logged into `https://decentphotos.example` and has completed the
authentication steps above. She wants to make a request to Bob's Pod to get a photo album
information at `https://bob.otherpod.example/private/photo_album.ttl`. Bob has previously
granted access to Alice but has not granted access to anyone else.

<h4 id="request-flow-step-2" class="no-num">2. Creates a DPoP header token</h4>

Before we send a request, we need to generate a DPoP header token. A new DPoP token must be
generated every time a request is made.

Generating a DPoP token is done the same way we did it in the authentication section. It must be signed by the same keypair that we generated in the authentication section. Our token
could look like the following (you can decode the token using https://jwt.io):
```text
eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiQ21HVE9Dd3ZKWXhrb0dGOGNxcFpBNTdab2xVdThBcFJQb3MwVlduWk1TNCIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiU0FZcmF5VUh4Z1FPQ29YSC1MbHdyOW1iSWJpUHBsLXRQRUpLeE1WWFltcyIsInkiOiJ6eGJQODdPQ3JpeEZpMk9vZjU1QkhsTC1ySHhvWHVuUmttNFBkV3duUzJnIn19.eyJodHUiOiJodHRwczovL2JvYi5vdGhlcnBvZC5leGFtcGxlL3ByaXZhdGUvcGhvdG9fYWxidW0udHRsIiwiaHRtIjoiZ2V0IiwianRpIjoiZmIxMjY0ZGQtZmZmMS00NTA5LWE3YjEtMGZlNThkMDhkM2UxIiwiaWF0IjoxNjAzMzg5NjE2LCJleHAiOjE2MDMzOTMyMTZ9.G8JktoMOadenCYtO4Z_ZI7ACnjKJvT59OyKlQ6WpB1Qq2GoCK6v1ocrpsfELDOKIL5nt5fwWccfvCAA2bMrkjA
```

Token Header:
```json
{
    "alg": "ES256",
    "typ": "dpop+jwt",
    "jwk": {
        "kty": "EC",
        "kid": "2i00gHnREsMhD5WqsABPSaqEjLC5MS-E98ykd-qtF1I",
        "use": "sig",
        "alg": "EC",
        "crv": "P-256",
        "x": "N6VsICiPA1ciAA82Jhv7ykkPL9B0ippUjmla8Snr4HY",
        "y": "ay9qDOrFGdGe_3hAivW5HnqHYdnYUkXJJevHOBU4z5s",
    }
}
```
- `"alg": "ES256"`: The signing algorithm used in this token. In this case, `ES256` because we
    generated the keys using eliptic curves.
- `"typ": "dpop+jwt"`: The type of token. All DPoP Tokens should have a type of "dpop+jwt"
- `"jwk": { "kty": "EC" ... }`: The client's public key.

Token Body:
```json
{
    "htu": "https://bob.otherpod.example/private/photo_album.ttl",
    "htm": "GET",
    "jti": "fb1264dd-fff1-4509-a7b1-0fe58d08d3e1",
    "iat": 1603389616
}
```
- `"htu": "https://bob.otherpod.example/private/photo_album.ttl"`: htu limits the token for
    use only on the given url.
- `"htm": "GET"`: htm limits the token for use only on a specific http method, in this case
    `POST`.
- `"jti": "fb1264dd-fff1-4509-a7b1-0fe58d08d3e1"`: jti is a unique identifier for the DPoP
    token that can optionally be used by the server to defend against replay attacks
- `"iat": 1603389616`: The date the token was issued, in this case October 22, 2020 14:00:16
    GMT.

<h4 id="request-flow-step-3" class="no-num">3. Sends request</h4>

With the access token and new DPoP token in hand, we're ready to make our request.

```http
GET https://bob.otherpod.example/private/photo_album.ttl
Headers: {
    authorization: "DPoP eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL2FsaWNlLmNvb2xwb2QuZXhhbXBsZS9wcm9maWxlL2NhcmQjbWUiLCJ3ZWJpZCI6Imh0dHBzOi8vYWxpY2UuY29vbHBvZC5leGFtcGxlL3Byb2ZpbGUvY2FyZCNtZSIsImlzcyI6Imh0dHBzOi8vc2VjdXJlYXV0aC5leGFtcGxlIiwiYXVkIjoic29saWQiLCJjbmYiOnsiamt0IjoiOVhtd0s4bVEzSDUtUG56QXQzbEZIeldCV192NVFoWXluZXpiYml0NGtDOCJ9LCJjbGllbnRfaWQiOiJodHRwczovL2RlY2VudHBob3Rvcy5leGFtcGxlL3dlYmlkI3RoaXMiLCJqdGkiOiJmZDBhMTM1My0yNWYzLTRjN2UtOGY4Yi1jMTQyNjRmMWMxMmUiLCJpYXQiOjE2MDMzODUyNjEsImV4cCI6MTYwMzM4NTg2MX0.HIIYiovILPvsdkD3s3xomR1MkA_Ir8Mx_C-eHxbWEnw9Z2rv2rOWbvMPZ--BqH3qVSupgYTZZsTDbZXA8giCLA",
    dpop: "eyJhbGciOiJFUzI1NiIsInR5cCI6ImRwb3Arand0IiwiandrIjp7Imt0eSI6IkVDIiwia2lkIjoiQ21HVE9Dd3ZKWXhrb0dGOGNxcFpBNTdab2xVdThBcFJQb3MwVlduWk1TNCIsInVzZSI6InNpZyIsImFsZyI6IkVDIiwiY3J2IjoiUC0yNTYiLCJ4IjoiU0FZcmF5VUh4Z1FPQ29YSC1MbHdyOW1iSWJpUHBsLXRQRUpLeE1WWFltcyIsInkiOiJ6eGJQODdPQ3JpeEZpMk9vZjU1QkhsTC1ySHhvWHVuUmttNFBkV3duUzJnIn19.eyJodHUiOiJodHRwczovL2JvYi5vdGhlcnBvZC5leGFtcGxlL3ByaXZhdGUvcGhvdG9fYWxidW0udHRsIiwiaHRtIjoiZ2V0IiwianRpIjoiZmIxMjY0ZGQtZmZmMS00NTA5LWE3YjEtMGZlNThkMDhkM2UxIiwiaWF0IjoxNjAzMzg5NjE2LCJleHAiOjE2MDMzOTMyMTZ9.G8JktoMOadenCYtO4Z_ZI7ACnjKJvT59OyKlQ6WpB1Qq2GoCK6v1ocrpsfELDOKIL5nt5fwWccfvCAA2bMrkjA"
}
```
- `headers.authorization: "DPoP eyJhbGciOiJFUzI1N..."`: The authorization header contains the
    ACCESS TOKEN that we received from the OP during the auth phase. Putting "DPoP" followed by a
    space tells the Resource Server that this is a DPoP bound access token.
- `dpop: "eyJhbGciOi..."`: The DPoP token we just generated.

<h4 id="request-flow-step-4" class="no-num">4. Checks Access Token expirations</h4>

The RS checks if the access token is still valid by looking at the `exp` claim. If the token
does not have an `exp` claim or the token is expired, the RS must reject the request with a 403.

<h4 id="request-flow-step-5" class="no-num">5. Checks the DPoP token url and method</h4>

The RS checks the `htu` and `htm` claims of the DPoP token. If the `htu` does not match the
protocol, origin and path of the request or the `htm` does not correspond the the http method
of the request, the RS must reject the request with a 403.

<h4 id="request-flow-step-5.1" class="no-num">5.1. (Optional) Checks DPoP token unique identifier</h4>

The RS can optionally keep track of all DPoP `jti` claims it received. Because a new DPoP token
must be generated each time a request is made, no two tokens should have the same `jti`. If the
RS receives a DPoP token with a `jti` it has already encountered it may reject the request with
a 403.

<h4 id="request-flow-step-6" class="no-num">6. Checks DPoP signature against Access Token</h4>

The RS first confirms that the DPoP token was signed by the public key listed in its `header
jwk`. If it was not, the RS must reject the request with a 403.

The RS checks if the public key in the DPoP token's `header.jwk` corresponds to the jwk
thumbprint in the access token in the `cnf` field. If they do not, the OP must reject the
request with a 403.

<h4 id="request-flow-step-7" class="no-num">7. Retrieves Profile</h4>

Using the `webid` claim in the access token (for us, it's
`https://alice.coolpod.example/profile/card#me`), the RS retreives the user's WebId document.

Request
```http
GET https://alice.coolpod.example/profile/card#me
```

Response
```ttl
@prefix : <#>.
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix schema: <http://schema.org/>.

<>
    a foaf:PersonalProfileDocument ;
    foaf:maker <https://localhost:8443/profile/card#me> ;
    foaf:primaryTopic <https://localhost:8443/profile/card#me> .

:me a foaf:Person ;
    a schema:Person ;
    foaf:name "Alice" ;
    solid:oidcIssuer <https://secureauth.example> ;
```

<h4 id="request-flow-step-8" class="no-num">8. Checks issuer</h4>

The RS checks that the `iss` claim in the access token matches the issuer listed in the user's
WebID. If it does not, the RS must reject the request with a 403.

<h4 id="request-flow-step-9" class="no-num">9. Retrieves OP configuration</h4>

The RS uses the `iss` claim to get the issuer's configuration. The url is the issuer claim with
`/.well-known/openid-configuration` appended to the end.

Request
```http
GET https://secureauth.example/.well-known/openid-configuration
```

Response
```json
{
    "issuer": "https://secureauth.example",
    "authorization_endpoint": "https://secureauth.example/authorize",
    "token_endpoint": "https://secureauth.example/token",
    "userinfo_endpoint": "https://secureauth.example/userinfo",
    "registration_endpoint": "https://secureauth.example/register",
    "end_session_endpoint": "https://secureauth.example/endsession",
    "jwks_uri": "https://secureauth.example/jwks",
    "response_types_supported": [
        "code"
    ],
    "grant_types_supported": [
        "authorization_code",
        "refresh_token"
    ],
    "subject_types_supported": [
        "public"
    ],
    "claims_supported": [
        "sub",
        "webid"
    ],
    "scopes_supported": [
        "openid",
        "profile",
        "email",
        "offline_access"
    ],
    "token_endpoint_auth_methods_supported": [
        "client_secret_basic"
    ],
    "token_endpoint_auth_signing_alg_values_supported": [
        "ES256"
    ],
    "request_object_signing_alg_values_supported": [
        "ES256"
    ],
    "id_token_signing_alg_values_supported": [
        "ES256"
    ],
    "code_challenge_methods_supported": [
        "plain",
        "S256"
    ],
    "claims_parameter_supported": false,
    "request_parameter_supported": true,
    "request_uri_parameter_supported": false,
    "require_request_uri_registration": false
}
```

<h4 id="request-flow-step-10" class="no-num">10. Requests JWKS</h4>

Using the `jwks_uri` field in the openid-configuration, the RS makes a request to retreive the
OP's public keys.

Request
```http
GET https://secureauth.example/jwks
```

Response (application/json)
```json
{
    "keys": [
        {
            "alg": "EC",
            "crv": "P-256",
            "kid": "Xu68Q0ZfwDiRfWOb2UE8N77GoEQQ7q58_3gl1wsKENs",
            "kty": "EC",
            "use": "sig",
            "x": "qBbrIQNVTIm7M88iJFVB3e1GqsbFbYYfFiibkd48_Ac",
            "y": "SCl_hDR_6SEuJhKFOiVo8-zLqNglZ56jiJw2_PNE9hU"
        }
    ]
}
```

Notice that the `keys` field is an array, so an OP could have multiple public keys.

<h4 id="request-flow-step-11" class="no-num">11. Checks access token signature validity</h4>

Using the `kid` value in the access token, the RS searches the OP keys for one that matches the
access token. Checks to see if the access token was signed by that key. If it was not, the RS
must reject the request with a 403.

<h4 id="request-flow-step-12" class="no-num">12. Performs Authorization</h4>

Now that the RS has performed all of its checks, we can trust that the agent in the `webid`
claim (`https://alice.coolpod.example/profile/card#me`) is the same agent on whose behalf the
request was made. Using that information, the RS performs authorization.

<h4 id="request-flow-step-13" class="no-num">13. Returns Result</h4>

Given all went well, the RS should return the requested content.

<pre class=biblio>
{
    "OpenIDConnect": {
        "authors": [
            "N. Sakimura",
            "J. Bradley",
            "M.B. Jones",
            "B. de Medeiros",
            "C. Mortimore"
        ],
        "href": "https://openid.net/specs/openid-connect-core-1_0.html",
        "title": "OpenID Connect Core 1.0",
        "publisher": "The OpenID Foundation"
    },
    "SolidOIDC": {
        "authors": [
            "A. Migus",
            "R. White"
        ],
        "href": "https://solid.github.io/authentication-panel/solid-oidc/",
        "title": "Solid OIDC",
        "publisher": "W3C"
    },
    "Solid": {
        "authors": [
            ""
        ],
        "href": "https://solid.github.io/specification/",
        "title": "The Solid Ecosystem",
        "publisher": "W3C"
    },
    "WebID": {
        "authors": [
            "A. Sambra",
            "H. Story",
            "T. Berners-Lee"
        ],
        "href": "https://dvcs.w3.org/hg/WebID/raw-file/tip/spec/identity-respec.html",
        "title": "WebID 1.0",
        "publisher": "W3C"
    }
}
</pre>
